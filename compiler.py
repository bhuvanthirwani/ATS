import subprocess
import pathlib
import os
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("LaTeXCompiler")

class LaTeXCompiler:
    def __init__(self, output_dir: pathlib.Path, compiler_path: str = "pdflatex"):
        self.output_dir = output_dir
        self.compiler_path = compiler_path
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def compile(self, tex_filename: str, timeout: int = 30) -> bool:
        """
        Compiles a .tex file to PDF using pdflatex.
        Returns True if successful, False otherwise.
        """
        tex_path = self.output_dir / tex_filename
        if not tex_path.exists():
            logger.error(f"TeX file not found: {tex_path}")
            return False

        try:
            # Run pdflatex
            # -interaction=nonstopmode: Don't stop on errors
            # -halt-on-error: Stop on the first error (optional, but cleaner)
            cmd = [
                self.compiler_path,
                "-interaction=nonstopmode",
                "-halt-on-error",
                tex_filename
            ]
            
            logger.info(f"Compiling {tex_filename} in {self.output_dir}...")
            result = subprocess.run(
                cmd,
                cwd=str(self.output_dir),
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                logger.info("Compilation successful.")
                # Cleanup auxiliary files
                self._cleanup(tex_filename.replace(".tex", ""))
                return True
            else:
                logger.error(f"Compilation failed with return code {result.returncode}")
                logger.error(f"STDOUT: {result.stdout}")
                logger.error(f"STDERR: {result.stderr}")
                return False

        except subprocess.TimeoutExpired:
            logger.error("Compilation timed out.")
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during compilation: {e}")
            return False

    def _cleanup(self, base_name: str):
        """Removes auxiliary files generated by LaTeX."""
        extensions = [".aux", ".log", ".out", ".toc"]
        for ext in extensions:
            file_path = self.output_dir / (base_name + ext)
            if file_path.exists():
                try:
                    file_path.unlink()
                except Exception as e:
                    logger.warning(f"Could not delete auxiliary file {file_path}: {e}")
